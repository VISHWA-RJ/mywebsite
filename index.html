
<!DOCTYPE html>
<html lang="en" style="display: flex; flex-direction: row; justify-content: center; align-items: stretch;"></html>
<html lang="en" style="display: flex; flex-direction: row; justify-content: center; align-items: stretch;"></html>
<!--
    Professional Research Center UI starter.
    For fuller visual redesign, adjust fonts, spacing and color variables in the <head> styles.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Small-World Network Simulation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            font-weight: 300;
            margin-top: 20px;
            color: #ffffff;
            text-align: center;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 15px 25px;
            background-color: #1e1e1e;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #a0a0a0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 5px;
            background: #444;
            border-radius: 5px;
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #03a9f4;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #1e1e1e;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #03a9f4;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #1e1e1e;
        }

        span {
            font-weight: 500;
            color: #03a9f4;
            min-width: 30px;
            text-align: center;
            margin-top: 5px;
            font-size: 14px;
        }

        button {
            background-color: #03a9f4;
            color: #ffffff;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0288d1;
        }

        #reset-cascade {
            background-color: #555;
        }
        #reset-cascade:hover {
            background-color: #777;
        }

        #graph-container {
            width: 95%;
            height: 80%;
            background-color: #181818;
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Small-World Network & Information Cascade</h1>
        <div class="controls">
            <div class="control-group">
                <label for="nodes">Number of Nodes</label>
                <input type="range" id="nodes" name="nodes" min="20" max="300" value="100">
                <span id="nodes-value">100</span>
            </div>
            <div class="control-group">
                <label for="neighbors">Neighbors (k)</label>
                <input type="range" id="neighbors" name="neighbors" min="2" max="14" value="4" step="2">
                <span id="neighbors-value">4</span>
            </div>
            <div class="control-group">
                <label for="beta">Rewiring Probability (Î²)</label>
                <input type="range" id="beta" name="beta" min="0" max="1" value="0.05" step="0.01">
                <span id="beta-value">0.05</span>
            </div>
            <button id="start-cascade">Start Information Cascade</button>
            <button id="reset-cascade">Reset</button>
        </div>
        <div id="graph-container"></div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // --- UI & STATE ---
        const nodesSlider = document.getElementById('nodes');
        const neighborsSlider = document.getElementById('neighbors');
        const betaSlider = document.getElementById('beta');
        const startButton = document.getElementById('start-cascade');
        const resetButton = document.getElementById('reset-cascade');
        let cascadeTimer = null; // To hold the interval timer

        // --- D3 SIMULATION SETUP ---
        const container = document.getElementById('graph-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        const svg = d3.select("#graph-container").append("svg")
            .attr("width", width)
            .attr("height", height);

        let link = svg.append("g").attr("class", "links").selectAll("line");
        let node = svg.append("g").attr("class", "nodes").selectAll("circle");
        let currentGraphData = {};

        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(40).strength(0.4))
            .force("charge", d3.forceManyBody().strength(-120))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .on("tick", ticked);

        // --- WATTS-STROGATZ MODEL GENERATOR ---
        function generateSmallWorldData(numNodes, k, beta) {
            const nodes = d3.range(numNodes).map(i => ({id: i}));
            const links = [];
            const linkSet = new Set();

            for (let i = 0; i < numNodes; i++) {
                for (let j = 1; j <= k / 2; j++) {
                    const target = (i + j) % numNodes;
                    const linkKey = i < target ? `${i}-${target}` : `${target}-${i}`;
                    if (!linkSet.has(linkKey)) {
                         links.push({ source: i, target: target });
                         linkSet.add(linkKey);
                    }
                }
            }

            links.forEach(link => {
                if (Math.random() < beta) {
                    const oldTarget = link.target;
                    let newTarget;
                    let newLinkKey;

                    do {
                        newTarget = Math.floor(Math.random() * numNodes);
                        newLinkKey = link.source < newTarget ? `${link.source}-${newTarget}` : `${newTarget}-${link.source}`;
                    } while (newTarget === link.source || linkSet.has(newLinkKey));

                    const oldLinkKey = link.source < oldTarget ? `${link.source}-${oldTarget}` : `${oldTarget}-${link.source}`;
                    linkSet.delete(oldLinkKey);
                    link.target = newTarget;
                    linkSet.add(newLinkKey);
                }
            });
            return { nodes, links };
        }

        // --- INFORMATION CASCADE LOGIC ---
        function startCascade() {
            resetCascade();
            if (!currentGraphData.nodes || currentGraphData.nodes.length === 0) return;

            const adjacency = new Map(currentGraphData.nodes.map(n => [n.id, []]));
            currentGraphData.links.forEach(l => {
                adjacency.get(l.source.id).push(l.target.id);
                adjacency.get(l.target.id).push(l.source.id);
            });

            let queue = [];
            const visited = new Set();

            const startNodeId = Math.floor(Math.random() * currentGraphData.nodes.length);
            queue.push(startNodeId);
            visited.add(startNodeId);

            d3.select(`circle[data-id='${startNodeId}']`)
                .transition().duration(200)
                .attr("fill", "#ffeb3b") // Starting node color
                .attr("r", 8);

            cascadeTimer = d3.interval(() => {
                const levelSize = queue.length;
                if (levelSize === 0) {
                    cascadeTimer.stop();
                    return;
                }

                let nextQueue = [];
                for (let i = 0; i < levelSize; i++) {
                    const u = queue[i];
                    adjacency.get(u).forEach(v => {
                        if (!visited.has(v)) {
                            visited.add(v);
                            nextQueue.push(v);
                            d3.select(`circle[data-id='${v}']`)
                                .transition().duration(300)
                                .attr("fill", "#f44336"); // Spreading info color
                        }
                    });
                }
                queue = nextQueue;
            }, 200);
        }

        function resetCascade() {
            if (cascadeTimer) cascadeTimer.stop();
            node.transition().duration(300)
                .attr("fill", "#03a9f4")
                .attr("r", 6);
        }

        // --- UPDATE AND RENDER FUNCTION ---
        function updateNetwork() {
            resetCascade();
            const numNodes = +nodesSlider.value;
            const k = +neighborsSlider.value;
            const beta = +betaSlider.value;

            currentGraphData = generateSmallWorldData(numNodes, k, beta);

            node = node.data(currentGraphData.nodes, d => d.id)
                .join(
                    enter => enter.append("circle")
                        .attr("r", 6)
                        .attr("fill", "#03a9f4")
                        .attr("stroke", "#121212")
                        .attr("stroke-width", 1.5)
                        .attr("data-id", d => d.id) // Add data-id for selection
                        .call(drag(simulation)),
                    update => update,
                    exit => exit.remove()
                );

            link = link.data(currentGraphData.links, d => `${d.source.id}-${d.target.id}`)
                .join(
                    enter => enter.append("line")
                        .attr("stroke-width", 1.5)
                        .attr("stroke", "#444"),
                    update => update,
                    exit => exit.remove()
                );

            simulation.nodes(currentGraphData.nodes);
            simulation.force("link").links(currentGraphData.links);
            simulation.alpha(0.8).restart();
        }

        // --- D3 HELPERS (TICK, DRAG) ---
        function ticked() {
            link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            node.attr("cx", d => d.x).attr("cy", d => d.y);
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x; d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null; d.fy = null;
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // --- EVENT LISTENERS & INITIALIZATION ---
        nodesSlider.oninput = () => {
            document.getElementById('nodes-value').textContent = nodesSlider.value;
            updateNetwork();
        };
        neighborsSlider.oninput = () => {
            document.getElementById('neighbors-value').textContent = neighborsSlider.value;
            updateNetwork();
        };
        betaSlider.oninput = () => {
            document.getElementById('beta-value').textContent = betaSlider.value;
            updateNetwork();
        };
        startButton.onclick = startCascade;
        resetButton.onclick = resetCascade;

        updateNetwork(); // Initial render

// Advanced controls, cascade engine, and monitoring panel injected dynamically
(function () {
    // Create advanced control panel
    const controlsBar = document.querySelector('.controls');
    const advPanel = document.createElement('div');
    advPanel.className = 'controls';
    advPanel.style.marginTop = '10px';
    advPanel.style.flexWrap = 'wrap';
    advPanel.style.justifyContent = 'center';
    advPanel.style.gap = '12px';
    advPanel.innerHTML = `
        <div class="control-group">
            <label for="adv-mode">Cascade Mode</label>
            <select id="adv-mode">
                <option value="prob">Probabilistic</option>
                <option value="threshold">Threshold</option>
            </select>
        </div>
        <div class="control-group">
            <label for="adv-prob">Infection Prob (p)</label>
            <input type="range" id="adv-prob" min="0" max="1" step="0.01" value="0.25">
            <span id="adv-prob-value">0.25</span>
        </div>
        <div class="control-group">
            <label for="adv-threshold">Threshold (fraction)</label>
            <input type="range" id="adv-threshold" min="0" max="1" step="0.01" value="0.5">
            <span id="adv-threshold-value">0.50</span>
        </div>
        <div class="control-group">
            <label for="adv-seeds">Initial Seeds</label>
            <input type="range" id="adv-seeds" min="1" max="20" step="1" value="1">
            <span id="adv-seeds-value">1</span>
        </div>
        <div class="control-group">
            <label for="adv-speed">Step ms (speed)</label>
            <input type="range" id="adv-speed" min="50" max="2000" step="10" value="300">
            <span id="adv-speed-value">300</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
            <button id="adv-start">Start Adv Cascade</button>
            <button id="adv-pause">Pause</button>
            <button id="adv-step">Step</button>
            <button id="adv-reset">Reset</button>
        </div>
    `;
    controlsBar.parentNode.insertBefore(advPanel, controlsBar.nextSibling);

    // Metrics panel
    const container = document.querySelector('.container');
    const metrics = document.createElement('div');
    metrics.style.marginTop = '12px';
    metrics.style.padding = '10px 14px';
    metrics.style.background = '#1e1e1e';
    metrics.style.borderRadius = '10px';
    metrics.style.color = '#aee';
    metrics.style.minWidth = '320px';
    metrics.innerHTML = `
        <div style="display:flex;gap:12px;flex-wrap:wrap">
            <div>Step: <span id="m-step">0</span></div>
            <div>Infected: <span id="m-infected">0</span></div>
            <div>% Infected: <span id="m-percent">0%</span></div>
            <div>Elapsed: <span id="m-elapsed">0s</span></div>
            <div>Avg Degree: <span id="m-avgdeg">0</span></div>
            <div>Clustering: <span id="m-clust">0</span></div>
        </div>
    `;
    container.appendChild(metrics);

    // Query controls (plain JS, no TypeScript casts)
    const modeSelect = document.getElementById('adv-mode');
    const probSlider = document.getElementById('adv-prob');
    const probValue = document.getElementById('adv-prob-value');
    const threshSlider = document.getElementById('adv-threshold');
    const threshValue = document.getElementById('adv-threshold-value');
    const seedsSlider = document.getElementById('adv-seeds');
    const seedsValue = document.getElementById('adv-seeds-value');
    const speedSlider = document.getElementById('adv-speed');
    const speedValue = document.getElementById('adv-speed-value');

    const startBtn = document.getElementById('adv-start');
    const pauseBtn = document.getElementById('adv-pause');
    const stepBtn = document.getElementById('adv-step');
    const resetBtn = document.getElementById('adv-reset');

    const metricsStep = document.getElementById('m-step');
    const metricsInfected = document.getElementById('m-infected');
    const metricsPercent = document.getElementById('m-percent');
    const metricsElapsed = document.getElementById('m-elapsed');
    const metricsAvgDeg = document.getElementById('m-avgdeg');
    const metricsClust = document.getElementById('m-clust');

    // State for advanced cascade (plain JS object)
    let adv = {
        status: new Map(), // nodeId -> 0 susceptible, 1 infected
        step: 0,
        startTime: null,
        timer: null,
        adjacency: new Map(),
        running: false
    };

    // Helpers
    function buildAdjacency() {
        const adj = new Map();
        if (!currentGraphData || !currentGraphData.nodes) return adj;
        currentGraphData.nodes.forEach(n => adj.set(n.id, []));
        currentGraphData.links.forEach(l => {
            const a = typeof l.source === 'object' ? l.source.id : l.source;
            const b = typeof l.target === 'object' ? l.target.id : l.target;
            adj.get(a).push(b);
            adj.get(b).push(a);
        });
        return adj;
    }

    function resetAdvState(clearVisual = true) {
        if (adv.timer) { adv.timer.stop(); adv.timer = null; }
        adv.status = new Map();
        adv.step = 0;
        adv.startTime = null;
        adv.running = false;
        adv.adjacency = buildAdjacency();
        if (currentGraphData && currentGraphData.nodes) {
            currentGraphData.nodes.forEach(n => adv.status.set(n.id, 0));
        }
        if (clearVisual) {
            d3.selectAll("circle")
                .transition().duration(200)
                .attr("fill", "#03a9f4")
                .attr("r", 6);
        }
        updateMetrics();
    }

    function seedInitialNodes(count) {
        if (!currentGraphData || !currentGraphData.nodes) return;
        const ids = currentGraphData.nodes.map(n => n.id);
        const picked = new Set();
        while (picked.size < Math.min(count, ids.length)) {
            const s = ids[Math.floor(Math.random() * ids.length)];
            picked.add(s);
        }
        picked.forEach(id => {
            adv.status.set(id, 1);
            d3.select(`circle[data-id='${id}']`)
                .transition().duration(150)
                .attr("fill", "#ffeb3b")
                .attr("r", 8);
        });
    }

    function stepCascadeOnce() {
        if (!currentGraphData || !currentGraphData.nodes) return;
        const mode = modeSelect ? modeSelect.value : 'prob';
        const p = probSlider ? parseFloat(probSlider.value) : 0.25;
        const thresh = threshSlider ? parseFloat(threshSlider.value) : 0.5;

        const newlyInfected = [];

        if (mode === 'prob') {
            // For each infected node, attempt to infect neighbors with prob p
            adv.status.forEach((st, id) => {
                if (st === 1) {
                    const neighbors = adv.adjacency.get(id) || [];
                    neighbors.forEach(nb => {
                        if (adv.status.get(nb) === 0) {
                            if (Math.random() < p) newlyInfected.push(nb);
                        }
                    });
                }
            });
        } else {
            // Threshold model: susceptible becomes infected if fraction infected neighbors >= thresh
            adv.status.forEach((st, id) => {
                if (st === 0) {
                    const neighbors = adv.adjacency.get(id) || [];
                    if (neighbors.length === 0) return;
                    const infectedNeighbors = neighbors.reduce((acc, nb) => acc + (adv.status.get(nb) === 1 ? 1 : 0), 0);
                    if ((infectedNeighbors / neighbors.length) >= thresh) newlyInfected.push(id);
                }
            });
        }

        // Apply new infections
        const uniqueNew = Array.from(new Set(newlyInfected));
        uniqueNew.forEach(id => adv.status.set(id, 1));

        // Visual update
        uniqueNew.forEach(id => {
            d3.select(`circle[data-id='${id}']`)
                .transition().duration(200)
                .attr("fill", "#f44336")
                .attr("r", 7);
        });

        adv.step += 1;
        updateMetrics();

        // stop if no changes
        const susceptibleLeft = Array.from(adv.status.values()).some(v => v === 0);
        if (uniqueNew.length === 0 || !susceptibleLeft) {
            stopAdvTimer();
        }
    }

    function startAdvTimer() {
        stopAdvTimer();
        const ms = speedSlider ? +speedSlider.value : 300;
        adv.startTime = adv.startTime || Date.now();
        adv.running = true;
        adv.timer = d3.interval(() => {
            stepCascadeOnce();
        }, ms);
    }

    function stopAdvTimer() {
        if (adv.timer) {
            adv.timer.stop();
            adv.timer = null;
        }
        adv.running = false;
    }

    function updateMetrics() {
        const total = (currentGraphData && currentGraphData.nodes) ? currentGraphData.nodes.length : 0;
        const infected = Array.from(adv.status.values()).filter(v => v === 1).length;
        const percent = total === 0 ? 0 : Math.round((infected / total) * 100);
        if (metricsStep) metricsStep.textContent = String(adv.step);
        if (metricsInfected) metricsInfected.textContent = String(infected);
        if (metricsPercent) metricsPercent.textContent = `${percent}%`;
        if (metricsElapsed) metricsElapsed.textContent = adv.startTime ? `${Math.round((Date.now() - adv.startTime) / 1000)}s` : '0s';

        // Average degree
        let sumDeg = 0;
        adv.adjacency.forEach(nebs => sumDeg += nebs.length);
        const avgDeg = adv.adjacency.size === 0 ? 0 : (sumDeg / adv.adjacency.size);
        if (metricsAvgDeg) metricsAvgDeg.textContent = avgDeg.toFixed(2);

        // Clustering coefficient (avg local clustering, approximate)
        let clustSum = 0;
        adv.adjacency.forEach((nebs, id) => {
            if (nebs.length < 2) return;
            let links = 0;
            for (let i = 0; i < nebs.length; i++) {
                for (let j = i + 1; j < nebs.length; j++) {
                    const a = nebs[i], b = nebs[j];
                    // check if edge exists between a and b
                    const nbList = adv.adjacency.get(a) || [];
                    if (nbList.includes(b)) links++;
                }
            }
            const possible = (nebs.length * (nebs.length - 1)) / 2;
            clustSum += (links / possible);
        });
        const clustAvg = adv.adjacency.size === 0 ? 0 : (clustSum / adv.adjacency.size);
        if (metricsClust) metricsClust.textContent = clustAvg.toFixed(3);
    }

    // UI bindings
    if (probSlider && probValue) probSlider.oninput = () => { probValue.textContent = probSlider.value; };
    if (threshSlider && threshValue) threshSlider.oninput = () => { threshValue.textContent = parseFloat(threshSlider.value).toFixed(2); };
    if (seedsSlider && seedsValue) seedsSlider.oninput = () => { seedsValue.textContent = seedsSlider.value; };
    if (speedSlider && speedValue) speedSlider.oninput = () => { speedValue.textContent = speedSlider.value; };

    if (startBtn) startBtn.onclick = () => {
        // reset any simple cascade timers from existing logic
        if (cascadeTimer) { cascadeTimer.stop(); cascadeTimer = null; }

        resetAdvState(false); // preserve visuals? false to clear
        adv.adjacency = buildAdjacency();

        // seed
        seedInitialNodes(parseInt((seedsSlider && seedsSlider.value) || '1', 10));
        updateMetrics();

        // start advancing
        startAdvTimer();
    };

    if (pauseBtn) pauseBtn.onclick = () => {
        if (adv.running) {
            stopAdvTimer();
            pauseBtn.textContent = 'Resume';
        } else {
            if (adv.timer == null) startAdvTimer();
            pauseBtn.textContent = 'Pause';
        }
    };

    if (stepBtn) stepBtn.onclick = () => {
        // single step without changing timer
        if (!adv.adjacency || adv.adjacency.size === 0) {
            adv.adjacency = buildAdjacency();
            // if no seed present, add one
            if (Array.from(adv.status.values()).every(v => v === 0)) seedInitialNodes(parseInt((seedsSlider && seedsSlider.value) || '1', 10));
        }
        stepCascadeOnce();
    };

    if (resetBtn) resetBtn.onclick = () => {
        stopAdvTimer();
        resetAdvState(true);
        if (pauseBtn) pauseBtn.textContent = 'Pause';
    };

    // Recompute adjacency & metrics whenever network changes
    // Hook into existing updateNetwork by observing currentGraphData changes periodically.
    // (Safer than modifying original function)
    let lastNodesVersion = null;
    d3.interval(() => {
        const curCount = currentGraphData && currentGraphData.nodes ? currentGraphData.nodes.length : 0;
        if (lastNodesVersion !== curCount) {
            lastNodesVersion = curCount;
            // rebuild adjacency and reset advanced state visually
            resetAdvState(true);
        }
    }, 800);

    // expose a lightweight API for debugging from console
    window.advCascade = {
        reset: resetAdvState,
        step: stepCascadeOnce,
        start: startAdvTimer,
        stop: stopAdvTimer,
        state: () => adv
    };

    // initialize
    resetAdvState(true);
})();

    </script>
</body>
</html>
